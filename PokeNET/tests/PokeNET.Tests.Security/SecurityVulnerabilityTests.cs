using System.Reflection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using PokeNET.Core.Assets;
using PokeNET.Core.Modding;
using PokeNET.Domain.Assets;
using PokeNET.Domain.Modding;
using PokeNET.Scripting.Security;
using Xunit;

namespace PokeNET.Tests.Security;

/// <summary>
/// Security validation tests for HIGH severity vulnerability fixes.
/// Tests VULN-001, VULN-006, VULN-009, and VULN-011.
/// </summary>
public class SecurityVulnerabilityTests
{
    #region VULN-001: CPU Timeout Bypass Tests

    [Fact]
    public async Task VULN001_InfiniteLoop_ShouldTimeout()
    {
        // Arrange
        var permissions = new ScriptPermissions
        {
            ScriptId = "timeout-test",
            MaxExecutionTime = TimeSpan.FromSeconds(1),
            MaxMemoryBytes = 10 * 1024 * 1024,
            AllowedNamespaces = new[] { "System" }
        };

        var sandbox = new ScriptSandbox(permissions);

        var maliciousScript = @"
            public class MaliciousScript
            {
                public static void Execute()
                {
                    // Infinite loop that ignores cancellation
                    while(true)
                    {
                        var x = 1 + 1; // Busy work
                    }
                }
            }
        ";

        // Act & Assert
        await Assert.ThrowsAnyAsync<Exception>(async () =>
        {
            var result = await sandbox.ExecuteAsync(maliciousScript);
            Assert.True(result.TimedOut || !result.Success,
                "Malicious infinite loop should timeout or fail");
        });
    }

    [Fact]
    public async Task VULN001_LongRunningTask_ShouldEnforceHardTimeout()
    {
        // Arrange
        var permissions = new ScriptPermissions
        {
            ScriptId = "hard-timeout-test",
            MaxExecutionTime = TimeSpan.FromMilliseconds(500),
            MaxMemoryBytes = 10 * 1024 * 1024,
            AllowedNamespaces = new[] { "System" }
        };

        var sandbox = new ScriptSandbox(permissions);

        var longRunningScript = @"
            using System.Threading;
            public class LongRunningScript
            {
                public static void Execute()
                {
                    Thread.Sleep(5000); // Sleep longer than timeout
                }
            }
        ";

        // Act
        var result = await sandbox.ExecuteAsync(longRunningScript);

        // Assert
        Assert.False(result.Success, "Long running script should not succeed");
        Assert.True(result.TimedOut || result.Exception != null,
            "Script should timeout or throw exception");
    }

    #endregion

    #region VULN-006: Path Traversal in ModLoader Tests

    [Fact]
    public void VULN006_ModPathTraversal_ShouldThrowSecurityException()
    {
        // Arrange
        var logger = NullLogger<ModLoader>.Instance;
        var modsDir = Path.Combine(Path.GetTempPath(), "test-mods");
        Directory.CreateDirectory(modsDir);

        var loader = new ModLoader(
            logger,
            new Microsoft.Extensions.DependencyInjection.ServiceCollection().BuildServiceProvider(),
            NullLoggerFactory.Instance,
            modsDir
        );

        var maliciousManifest = new ModManifest
        {
            Id = "../../../etc/passwd", // Path traversal attempt
            Name = "Malicious Mod",
            Version = "1.0.0",
            ModType = ModType.Code
        };

        // Act & Assert
        var ex = Assert.Throws<System.Security.SecurityException>(() =>
        {
            // Use reflection to call private LoadMod method
            var loadModMethod = typeof(ModLoader).GetMethod(
                "LoadMod",
                BindingFlags.NonPublic | BindingFlags.Instance
            );
            loadModMethod?.Invoke(loader, new[] { maliciousManifest });
        });

        Assert.Contains("path traversal", ex.Message.ToLower());

        // Cleanup
        Directory.Delete(modsDir, true);
    }

    [Fact]
    public void VULN006_ModIdWithBackslashes_ShouldThrowSecurityException()
    {
        // Arrange
        var logger = NullLogger<ModLoader>.Instance;
        var modsDir = Path.Combine(Path.GetTempPath(), "test-mods-2");
        Directory.CreateDirectory(modsDir);

        var loader = new ModLoader(
            logger,
            new Microsoft.Extensions.DependencyInjection.ServiceCollection().BuildServiceProvider(),
            NullLoggerFactory.Instance,
            modsDir
        );

        var maliciousManifest = new ModManifest
        {
            Id = "..\\..\\windows\\system32", // Windows path traversal
            Name = "Malicious Mod",
            Version = "1.0.0",
            ModType = ModType.Code
        };

        // Act & Assert
        var ex = Assert.Throws<System.Security.SecurityException>(() =>
        {
            var loadModMethod = typeof(ModLoader).GetMethod(
                "LoadMod",
                BindingFlags.NonPublic | BindingFlags.Instance
            );
            loadModMethod?.Invoke(loader, new[] { maliciousManifest });
        });

        Assert.Contains("path traversal", ex.Message.ToLower());

        // Cleanup
        Directory.Delete(modsDir, true);
    }

    [Fact]
    public void VULN006_ModIdWithForwardSlashes_ShouldThrowSecurityException()
    {
        // Arrange
        var logger = NullLogger<ModLoader>.Instance;
        var modsDir = Path.Combine(Path.GetTempPath(), "test-mods-3");
        Directory.CreateDirectory(modsDir);

        var loader = new ModLoader(
            logger,
            new Microsoft.Extensions.DependencyInjection.ServiceCollection().BuildServiceProvider(),
            NullLoggerFactory.Instance,
            modsDir
        );

        var maliciousManifest = new ModManifest
        {
            Id = "../../../root/.ssh", // Unix path traversal
            Name = "Malicious Mod",
            Version = "1.0.0",
            ModType = ModType.Code
        };

        // Act & Assert
        var ex = Assert.Throws<System.Security.SecurityException>(() =>
        {
            var loadModMethod = typeof(ModLoader).GetMethod(
                "LoadMod",
                BindingFlags.NonPublic | BindingFlags.Instance
            );
            loadModMethod?.Invoke(loader, new[] { maliciousManifest });
        });

        Assert.Contains("path traversal", ex.Message.ToLower());

        // Cleanup
        Directory.Delete(modsDir, true);
    }

    #endregion

    #region VULN-009: Unrestricted Harmony Patching Tests

    [Fact]
    public void VULN009_PatchSecurityCriticalType_ShouldThrowSecurityException()
    {
        // Arrange
        var logger = NullLogger<HarmonyPatcher>.Instance;
        var patcher = new HarmonyPatcher(logger);

        // Create a mock assembly with patches targeting blocked types
        // This test verifies the validation logic without needing actual Harmony patches

        // For this test, we'll verify the validation method directly
        var validateMethod = typeof(HarmonyPatcher).GetMethod(
            "ValidatePatchTarget",
            BindingFlags.NonPublic | BindingFlags.Instance
        );

        // Act & Assert - Try to patch ModLoader (blocked)
        var ex1 = Assert.Throws<System.Security.SecurityException>(() =>
        {
            validateMethod?.Invoke(patcher, new object[]
            {
                "PokeNET.Core.Modding.ModLoader",
                "MaliciousPatch"
            });
        });
        Assert.Contains("blocked", ex1.Message.ToLower());

        // Act & Assert - Try to patch ScriptSandbox (blocked)
        var ex2 = Assert.Throws<System.Security.SecurityException>(() =>
        {
            validateMethod?.Invoke(patcher, new object[]
            {
                "PokeNET.Scripting.Security.ScriptSandbox",
                "MaliciousPatch"
            });
        });
        Assert.Contains("blocked", ex2.Message.ToLower());

        // Act & Assert - Try to patch System.Security (blocked)
        var ex3 = Assert.Throws<System.Security.SecurityException>(() =>
        {
            validateMethod?.Invoke(patcher, new object[]
            {
                "System.Security.Permissions",
                "MaliciousPatch"
            });
        });
        Assert.Contains("blocked", ex3.Message.ToLower());
    }

    [Fact]
    public void VULN009_PatchNonAllowlistedType_ShouldThrowSecurityException()
    {
        // Arrange
        var logger = NullLogger<HarmonyPatcher>.Instance;
        var patcher = new HarmonyPatcher(logger);

        var validateMethod = typeof(HarmonyPatcher).GetMethod(
            "ValidatePatchTarget",
            BindingFlags.NonPublic | BindingFlags.Instance
        );

        // Act & Assert - Try to patch a random type not in allowlist
        var ex = Assert.Throws<System.Security.SecurityException>(() =>
        {
            validateMethod?.Invoke(patcher, new object[]
            {
                "SomeRandomNamespace.SomeRandomClass",
                "UnauthorizedPatch"
            });
        });

        Assert.Contains("not in the allowlist", ex.Message.ToLower());
    }

    [Fact]
    public void VULN009_PatchAllowedType_ShouldSucceed()
    {
        // Arrange
        var logger = NullLogger<HarmonyPatcher>.Instance;
        var patcher = new HarmonyPatcher(logger);

        var validateMethod = typeof(HarmonyPatcher).GetMethod(
            "ValidatePatchTarget",
            BindingFlags.NonPublic | BindingFlags.Instance
        );

        // Act & Assert - Patch an allowed type should not throw
        var exception = Record.Exception(() =>
        {
            validateMethod?.Invoke(patcher, new object[]
            {
                "PokeNET.Domain.ECS.Systems.BattleSystem",
                "LegitPatch"
            });
        });

        Assert.Null(exception);
    }

    #endregion

    #region VULN-011: Asset Path Traversal Tests

    [Fact]
    public void VULN011_AssetPathWithDotDot_ShouldThrowException()
    {
        // Arrange
        var logger = NullLogger<AssetManager>.Instance;
        var basePath = Path.Combine(Path.GetTempPath(), "test-assets");
        Directory.CreateDirectory(basePath);

        var assetManager = new AssetManager(logger, basePath);

        // Act & Assert
        var ex = Assert.Throws<AssetLoadException>(() =>
        {
            assetManager.Load<string>("../../etc/passwd");
        });

        Assert.Contains("traversal", ex.Message.ToLower());

        // Cleanup
        Directory.Delete(basePath, true);
    }

    [Fact]
    public void VULN011_AssetPathAbsolute_ShouldThrowException()
    {
        // Arrange
        var logger = NullLogger<AssetManager>.Instance;
        var basePath = Path.Combine(Path.GetTempPath(), "test-assets-2");
        Directory.CreateDirectory(basePath);

        var assetManager = new AssetManager(logger, basePath);

        // Act & Assert
        var ex = Assert.Throws<AssetLoadException>(() =>
        {
            assetManager.Load<string>("/etc/passwd");
        });

        Assert.Contains("relative", ex.Message.ToLower());

        // Cleanup
        Directory.Delete(basePath, true);
    }

    [Fact]
    public void VULN011_AssetPathWindowsAbsolute_ShouldThrowException()
    {
        // Arrange
        var logger = NullLogger<AssetManager>.Instance;
        var basePath = Path.Combine(Path.GetTempPath(), "test-assets-3");
        Directory.CreateDirectory(basePath);

        var assetManager = new AssetManager(logger, basePath);

        // Act & Assert
        var ex = Assert.Throws<AssetLoadException>(() =>
        {
            assetManager.Load<string>("C:\\Windows\\System32\\config");
        });

        Assert.Contains("relative", ex.Message.ToLower());

        // Cleanup
        Directory.Delete(basePath, true);
    }

    [Fact]
    public void VULN011_AssetPathNormalized_ShouldSucceed()
    {
        // Arrange
        var logger = NullLogger<AssetManager>.Instance;
        var basePath = Path.Combine(Path.GetTempPath(), "test-assets-4");
        Directory.CreateDirectory(basePath);

        // Create a test file
        var testFilePath = Path.Combine(basePath, "test.txt");
        File.WriteAllText(testFilePath, "test content");

        var assetManager = new AssetManager(logger, basePath);
        assetManager.RegisterLoader(new TextAssetLoader());

        // Act - Normal relative path should work
        var asset = assetManager.Load<string>("test.txt");

        // Assert
        Assert.Equal("test content", asset);

        // Cleanup
        Directory.Delete(basePath, true);
    }

    #endregion

    #region Helper Classes

    private class TextAssetLoader : IAssetLoader<string>
    {
        public string Load(string path)
        {
            return File.ReadAllText(path);
        }

        public bool CanHandle(string extension)
        {
            return extension == ".txt";
        }
    }

    #endregion
}
